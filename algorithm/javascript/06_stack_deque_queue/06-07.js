/*
  최소 매출  
  
  제과점. N일 동안 매출기록으로
  연속된 K일 동안의 최소 매출액을 차례로 구하기.

  예시
  만약 N = 10이고 10일간 매출기록이
  11 12 15 20 25 10 20 13 15 19일 때
  
  K = 3이면
  [11, 12, 15] 중에서 제일 적은 11.
  [12, 15, 20] 중에서 제일 적은 12.
  이런식으로 구해서 [11, 12, 15, 10, 10, 10, 13, 13].

*/

// 강사님.
// 자바스크립트의 배열이 데크다. 뒤에서 push하고 pop된다.
// 앞에서 unshift, shift 된다.

// 데크는 뒤쪽에서 넣었다 뺐다할 수 있고.
// 앞쪽에서도 넣었다 뻈다 할 수 있다.

// 이번 문제는 n^2 쓰면 효율성 바로 탈락.
// 3개씩 비교하면 안되고 데크를 무조건 써야한다.

// queue에 넣을 때 [nums[i], i] 이렇게 하나씩 넣어라.
// 이렇게 되게. >> (11,0) (12,1) (15,2)
// 데크의 맨 앞이 최소라 생각하고. 쭉 간다.

// 다시 설명.
// 데크에 (11,0) (12,1) 넣고
// for문 k-1부터 돈다. 2번인덱스에 있는 것을 넣는다. (데크 맨 뒤부터 크다면)
// (11,0)(12,1)(15,2) 11푸쉬.
// 최소값 찾고 앞에꺼 뺀다. (제일앞에 인덱스가 i-k+1)
// (12,1), (15,2) 된다. 
// ---------여기까지 for문 루틴.

// 더 작다면 뒤쪽에서 pop시켜버린다.
// 그 다음꺼는 비어있으면 들어간다.

// function solution(nums, k) {
    
// }

// console.log(solution([11, 12, 15, 13, 25, 10, 20, 13, 15, 19], 3))
// 4번인덱스 20 -> 13으로 바꿈.


// 어려운 문제고 손으로 꼭해봐야 한다. 그리고 이건 반복숙달하면서 외우는 수준으로 해라.
// 강사님 코드
function solution(nums, k) {
    let answer = [];
    let deque = [];

    for(let i=0; i<k-1; i++) { // 2개를 일단 deque에 넣기위한 세팅.
      while(deque.length>0 && deque[deque.length-1][0]>nums[i]) {
        deque.pop(); // 여기가 포인트.
      }
      deque.push([nums[i], i]); // deque에 없다면
    }
    for(let i=k-1; i<nums.length; i++) {
      while(deque.length>0 && deque[deque.length-1][0]>nums[i]) {
        deque.pop(); // 나보다 더 크면 나와.
      }
      deque.push([nums[i], i]);
      answer.push(deque[0][0]);
      if(deque[0][1]===i-k+1) {
        deque.shift();
      }
      // 크면 뒤쪽에서 뺴고 있어서 오름차순을 유지하고 있다.
    }
    return answer;
}

console.log(solution([11, 12, 15, 13, 25, 10, 20, 13, 15, 19], 3))
// ❗️ 테스트할때는 한자리 숫자로 해라.

// 15, 16, 10, 20, 25, 30 이러면 계속 10이 남아있을꺼고 구간을넘어서서?