// 경로
// [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]]

// 노드 개수이자 목적지 N
// 5

// 문제
// N으로 갈 수 있는 경우의 수


// 보고 따라하기1
// try1
// 노드개수만큼 빈 `````````````````````````````````행렬을 만든다.
// 각 행당 갈 수 있는 곳을 배열에 넣는다.
// 한번 간 곳은 다시 가지 않는다. 노드개수만큼 빈 배열을 만들어서 1을 넣었다가 뺐다가 하자.

// 정답보고
// 노드 개수 +1 만큼 배열안에 빈 배열을 만든다.
// 간 곳을 다시 가지 않기 위해 check라는 변수배열을 만들고 0으로 초기화해준다. 즉, 배열안에 0개 n+1개 만든다.
// 배열안에 만든 빈배열 6개에 각 노드가 갈 수 있는 방향들을 넣는다.
// 여기까지 초기 세팅!

function solution(n, edges) {
    let answer = 0;
    let graph = Array.from({length:n+1}, ()=>Array()); // 배열안에 빈배열 6개 만든다. 제일 앞에 빈 배열은 하나 버리게 될 것.
    let ch = Array.from({length:n+1}, ()=>0); // 체크도 마찬가지
    for (let [a, b] of edges) {
        graph[a].push(b);
    }
    let path=[]; // 경로를 보기 위한 용도로 사용하자.

    function DFS(v) { // 정점은 v로 표현.
        if(v===n) { // 끝나는 조건 정점이 n일 때. v가 하나씩 올라가면서 5가 됬을 때 끝난다.
            answer++;
        }
        else {
            // 1에서 2가고 2에서 어디가고 경로 따라서 쭉 간다.
            // graph에서 노드1이 갈 수 있는 경로에 들어있는 것 부터 하나씩 꺼낸다.
            for(let nv of graph[v]) {
                // 방문한적이 없었을 때만 DFS를 쭉~ 진행해나간다.
                if(ch[nv] === 0) {
                    ch[nv]=1; // 갔었다고 체크한다.
                    path.push(nv);
                    DFS(nv);
                    ch[nv]=0; 
                }
            }
        }
    }

    ch[1] = 1; // 1부터 시작할꺼라서 1은 방문했다고 방문처리하고 시작.
    path.push(1);
    DFS(1) // 1부터 시작.
    return answer;
}

console.log(solution(5, [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]])) // 6